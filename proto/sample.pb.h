// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sample.proto

#ifndef PROTOBUF_sample_2eproto__INCLUDED
#define PROTOBUF_sample_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ADSB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_sample_2eproto();
void protobuf_AssignDesc_sample_2eproto();
void protobuf_ShutdownFile_sample_2eproto();

class GeoCoordinates;
class Aircraft;
class Source;
class ADSB_Message;
class Sample;

enum ADSB_Message_SourceType {
  ADSB_Message_SourceType_Sample = 1
};
bool ADSB_Message_SourceType_IsValid(int value);
const ADSB_Message_SourceType ADSB_Message_SourceType_SourceType_MIN = ADSB_Message_SourceType_Sample;
const ADSB_Message_SourceType ADSB_Message_SourceType_SourceType_MAX = ADSB_Message_SourceType_Sample;
const int ADSB_Message_SourceType_SourceType_ARRAYSIZE = ADSB_Message_SourceType_SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ADSB_Message_SourceType_descriptor();
inline const ::std::string& ADSB_Message_SourceType_Name(ADSB_Message_SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ADSB_Message_SourceType_descriptor(), value);
}
inline bool ADSB_Message_SourceType_Parse(
    const ::std::string& name, ADSB_Message_SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ADSB_Message_SourceType>(
    ADSB_Message_SourceType_descriptor(), name, value);
}
// ===================================================================

class GeoCoordinates : public ::google::protobuf::Message {
 public:
  GeoCoordinates();
  virtual ~GeoCoordinates();

  GeoCoordinates(const GeoCoordinates& from);

  inline GeoCoordinates& operator=(const GeoCoordinates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoCoordinates& default_instance();

  void Swap(GeoCoordinates* other);

  // implements Message ----------------------------------------------

  GeoCoordinates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoCoordinates& from);
  void MergeFrom(const GeoCoordinates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);

  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline double altitude() const;
  inline void set_altitude(double value);

  // optional uint32 epsg = 4;
  inline bool has_epsg() const;
  inline void clear_epsg();
  static const int kEpsgFieldNumber = 4;
  inline ::google::protobuf::uint32 epsg() const;
  inline void set_epsg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ADSB.GeoCoordinates)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_epsg();
  inline void clear_has_epsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double latitude_;
  double longitude_;
  double altitude_;
  ::google::protobuf::uint32 epsg_;
  friend void  protobuf_AddDesc_sample_2eproto();
  friend void protobuf_AssignDesc_sample_2eproto();
  friend void protobuf_ShutdownFile_sample_2eproto();

  void InitAsDefaultInstance();
  static GeoCoordinates* default_instance_;
};
// -------------------------------------------------------------------

class Aircraft : public ::google::protobuf::Message {
 public:
  Aircraft();
  virtual ~Aircraft();

  Aircraft(const Aircraft& from);

  inline Aircraft& operator=(const Aircraft& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Aircraft& default_instance();

  void Swap(Aircraft* other);

  // implements Message ----------------------------------------------

  Aircraft* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Aircraft& from);
  void MergeFrom(const Aircraft& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required string icao24 = 2;
  inline bool has_icao24() const;
  inline void clear_icao24();
  static const int kIcao24FieldNumber = 2;
  inline const ::std::string& icao24() const;
  inline void set_icao24(const ::std::string& value);
  inline void set_icao24(const char* value);
  inline void set_icao24(const char* value, size_t size);
  inline ::std::string* mutable_icao24();
  inline ::std::string* release_icao24();
  inline void set_allocated_icao24(::std::string* icao24);

  // required string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .ADSB.GeoCoordinates position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::ADSB::GeoCoordinates& position() const;
  inline ::ADSB::GeoCoordinates* mutable_position();
  inline ::ADSB::GeoCoordinates* release_position();
  inline void set_allocated_position(::ADSB::GeoCoordinates* position);

  // optional double gpsCourse = 6;
  inline bool has_gpscourse() const;
  inline void clear_gpscourse();
  static const int kGpsCourseFieldNumber = 6;
  inline double gpscourse() const;
  inline void set_gpscourse(double value);

  // optional double aerialSpeed = 7;
  inline bool has_aerialspeed() const;
  inline void clear_aerialspeed();
  static const int kAerialSpeedFieldNumber = 7;
  inline double aerialspeed() const;
  inline void set_aerialspeed(double value);

  // optional double aerialAlt = 8;
  inline bool has_aerialalt() const;
  inline void clear_aerialalt();
  static const int kAerialAltFieldNumber = 8;
  inline double aerialalt() const;
  inline void set_aerialalt(double value);

  // optional double verticalSpeed = 9;
  inline bool has_verticalspeed() const;
  inline void clear_verticalspeed();
  static const int kVerticalSpeedFieldNumber = 9;
  inline double verticalspeed() const;
  inline void set_verticalspeed(double value);

  // optional string description = 10;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 10;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:ADSB.Aircraft)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_icao24();
  inline void clear_has_icao24();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_gpscourse();
  inline void clear_has_gpscourse();
  inline void set_has_aerialspeed();
  inline void clear_has_aerialspeed();
  inline void set_has_aerialalt();
  inline void clear_has_aerialalt();
  inline void set_has_verticalspeed();
  inline void clear_has_verticalspeed();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* icao24_;
  ::std::string* id_;
  ::ADSB::GeoCoordinates* position_;
  double gpscourse_;
  double aerialspeed_;
  double aerialalt_;
  double verticalspeed_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_sample_2eproto();
  friend void protobuf_AssignDesc_sample_2eproto();
  friend void protobuf_ShutdownFile_sample_2eproto();

  void InitAsDefaultInstance();
  static Aircraft* default_instance_;
};
// -------------------------------------------------------------------

class Source : public ::google::protobuf::Message {
 public:
  Source();
  virtual ~Source();

  Source(const Source& from);

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Source& default_instance();

  void Swap(Source* other);

  // implements Message ----------------------------------------------

  Source* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sourceName = 1;
  inline bool has_sourcename() const;
  inline void clear_sourcename();
  static const int kSourceNameFieldNumber = 1;
  inline const ::std::string& sourcename() const;
  inline void set_sourcename(const ::std::string& value);
  inline void set_sourcename(const char* value);
  inline void set_sourcename(const char* value, size_t size);
  inline ::std::string* mutable_sourcename();
  inline ::std::string* release_sourcename();
  inline void set_allocated_sourcename(::std::string* sourcename);

  // optional string deviceName = 2;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 2;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  inline void set_allocated_devicename(::std::string* devicename);

  // @@protoc_insertion_point(class_scope:ADSB.Source)
 private:
  inline void set_has_sourcename();
  inline void clear_has_sourcename();
  inline void set_has_devicename();
  inline void clear_has_devicename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sourcename_;
  ::std::string* devicename_;
  friend void  protobuf_AddDesc_sample_2eproto();
  friend void protobuf_AssignDesc_sample_2eproto();
  friend void protobuf_ShutdownFile_sample_2eproto();

  void InitAsDefaultInstance();
  static Source* default_instance_;
};
// -------------------------------------------------------------------

class ADSB_Message : public ::google::protobuf::Message {
 public:
  ADSB_Message();
  virtual ~ADSB_Message();

  ADSB_Message(const ADSB_Message& from);

  inline ADSB_Message& operator=(const ADSB_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ADSB_Message& default_instance();

  void Swap(ADSB_Message* other);

  // implements Message ----------------------------------------------

  ADSB_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ADSB_Message& from);
  void MergeFrom(const ADSB_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ADSB_Message_SourceType SourceType;
  static const SourceType Sample = ADSB_Message_SourceType_Sample;
  static inline bool SourceType_IsValid(int value) {
    return ADSB_Message_SourceType_IsValid(value);
  }
  static const SourceType SourceType_MIN =
    ADSB_Message_SourceType_SourceType_MIN;
  static const SourceType SourceType_MAX =
    ADSB_Message_SourceType_SourceType_MAX;
  static const int SourceType_ARRAYSIZE =
    ADSB_Message_SourceType_SourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SourceType_descriptor() {
    return ADSB_Message_SourceType_descriptor();
  }
  static inline const ::std::string& SourceType_Name(SourceType value) {
    return ADSB_Message_SourceType_Name(value);
  }
  static inline bool SourceType_Parse(const ::std::string& name,
      SourceType* value) {
    return ADSB_Message_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ADSB.ADSB_Message.SourceType sourceType = 1;
  inline bool has_sourcetype() const;
  inline void clear_sourcetype();
  static const int kSourceTypeFieldNumber = 1;
  inline ::ADSB::ADSB_Message_SourceType sourcetype() const;
  inline void set_sourcetype(::ADSB::ADSB_Message_SourceType value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ADSB_Message)
  // @@protoc_insertion_point(class_scope:ADSB.ADSB_Message)
 private:
  inline void set_has_sourcetype();
  inline void clear_has_sourcetype();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int sourcetype_;
  friend void  protobuf_AddDesc_sample_2eproto();
  friend void protobuf_AssignDesc_sample_2eproto();
  friend void protobuf_ShutdownFile_sample_2eproto();

  void InitAsDefaultInstance();
  static ADSB_Message* default_instance_;
};
// -------------------------------------------------------------------

class Sample : public ::google::protobuf::Message {
 public:
  Sample();
  virtual ~Sample();

  Sample(const Sample& from);

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample& default_instance();

  void Swap(Sample* other);

  // implements Message ----------------------------------------------

  Sample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ADSB.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::ADSB::Source& source() const;
  inline ::ADSB::Source* mutable_source();
  inline ::ADSB::Source* release_source();
  inline void set_allocated_source(::ADSB::Source* source);

  // repeated .ADSB.Aircraft aircraft = 2;
  inline int aircraft_size() const;
  inline void clear_aircraft();
  static const int kAircraftFieldNumber = 2;
  inline const ::ADSB::Aircraft& aircraft(int index) const;
  inline ::ADSB::Aircraft* mutable_aircraft(int index);
  inline ::ADSB::Aircraft* add_aircraft();
  inline const ::google::protobuf::RepeatedPtrField< ::ADSB::Aircraft >&
      aircraft() const;
  inline ::google::protobuf::RepeatedPtrField< ::ADSB::Aircraft >*
      mutable_aircraft();

  static const int kDataFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ADSB::ADSB_Message,
      ::google::protobuf::internal::MessageTypeTraits< ::ADSB::Sample >, 11, false >
    data;
  // @@protoc_insertion_point(class_scope:ADSB.Sample)
 private:
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ADSB::Source* source_;
  ::google::protobuf::RepeatedPtrField< ::ADSB::Aircraft > aircraft_;
  friend void  protobuf_AddDesc_sample_2eproto();
  friend void protobuf_AssignDesc_sample_2eproto();
  friend void protobuf_ShutdownFile_sample_2eproto();

  void InitAsDefaultInstance();
  static Sample* default_instance_;
};
// ===================================================================


// ===================================================================

// GeoCoordinates

// required double latitude = 1;
inline bool GeoCoordinates::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoCoordinates::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoCoordinates::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoCoordinates::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GeoCoordinates::latitude() const {
  // @@protoc_insertion_point(field_get:ADSB.GeoCoordinates.latitude)
  return latitude_;
}
inline void GeoCoordinates::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ADSB.GeoCoordinates.latitude)
}

// required double longitude = 2;
inline bool GeoCoordinates::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoCoordinates::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoCoordinates::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoCoordinates::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GeoCoordinates::longitude() const {
  // @@protoc_insertion_point(field_get:ADSB.GeoCoordinates.longitude)
  return longitude_;
}
inline void GeoCoordinates::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ADSB.GeoCoordinates.longitude)
}

// optional double altitude = 3;
inline bool GeoCoordinates::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoCoordinates::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoCoordinates::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoCoordinates::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double GeoCoordinates::altitude() const {
  // @@protoc_insertion_point(field_get:ADSB.GeoCoordinates.altitude)
  return altitude_;
}
inline void GeoCoordinates::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:ADSB.GeoCoordinates.altitude)
}

// optional uint32 epsg = 4;
inline bool GeoCoordinates::has_epsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoCoordinates::set_has_epsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoCoordinates::clear_has_epsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoCoordinates::clear_epsg() {
  epsg_ = 0u;
  clear_has_epsg();
}
inline ::google::protobuf::uint32 GeoCoordinates::epsg() const {
  // @@protoc_insertion_point(field_get:ADSB.GeoCoordinates.epsg)
  return epsg_;
}
inline void GeoCoordinates::set_epsg(::google::protobuf::uint32 value) {
  set_has_epsg();
  epsg_ = value;
  // @@protoc_insertion_point(field_set:ADSB.GeoCoordinates.epsg)
}

// -------------------------------------------------------------------

// Aircraft

// required uint64 timestamp = 1;
inline bool Aircraft::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Aircraft::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Aircraft::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Aircraft::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Aircraft::timestamp() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.timestamp)
  return timestamp_;
}
inline void Aircraft::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.timestamp)
}

// required string icao24 = 2;
inline bool Aircraft::has_icao24() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Aircraft::set_has_icao24() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Aircraft::clear_has_icao24() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Aircraft::clear_icao24() {
  if (icao24_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icao24_->clear();
  }
  clear_has_icao24();
}
inline const ::std::string& Aircraft::icao24() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.icao24)
  return *icao24_;
}
inline void Aircraft::set_icao24(const ::std::string& value) {
  set_has_icao24();
  if (icao24_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icao24_ = new ::std::string;
  }
  icao24_->assign(value);
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.icao24)
}
inline void Aircraft::set_icao24(const char* value) {
  set_has_icao24();
  if (icao24_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icao24_ = new ::std::string;
  }
  icao24_->assign(value);
  // @@protoc_insertion_point(field_set_char:ADSB.Aircraft.icao24)
}
inline void Aircraft::set_icao24(const char* value, size_t size) {
  set_has_icao24();
  if (icao24_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icao24_ = new ::std::string;
  }
  icao24_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ADSB.Aircraft.icao24)
}
inline ::std::string* Aircraft::mutable_icao24() {
  set_has_icao24();
  if (icao24_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icao24_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ADSB.Aircraft.icao24)
  return icao24_;
}
inline ::std::string* Aircraft::release_icao24() {
  clear_has_icao24();
  if (icao24_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icao24_;
    icao24_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Aircraft::set_allocated_icao24(::std::string* icao24) {
  if (icao24_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icao24_;
  }
  if (icao24) {
    set_has_icao24();
    icao24_ = icao24;
  } else {
    clear_has_icao24();
    icao24_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Aircraft.icao24)
}

// required string id = 3;
inline bool Aircraft::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Aircraft::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Aircraft::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Aircraft::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Aircraft::id() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.id)
  return *id_;
}
inline void Aircraft::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.id)
}
inline void Aircraft::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ADSB.Aircraft.id)
}
inline void Aircraft::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ADSB.Aircraft.id)
}
inline ::std::string* Aircraft::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ADSB.Aircraft.id)
  return id_;
}
inline ::std::string* Aircraft::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Aircraft::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Aircraft.id)
}

// required .ADSB.GeoCoordinates position = 4;
inline bool Aircraft::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Aircraft::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Aircraft::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Aircraft::clear_position() {
  if (position_ != NULL) position_->::ADSB::GeoCoordinates::Clear();
  clear_has_position();
}
inline const ::ADSB::GeoCoordinates& Aircraft::position() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::ADSB::GeoCoordinates* Aircraft::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::ADSB::GeoCoordinates;
  // @@protoc_insertion_point(field_mutable:ADSB.Aircraft.position)
  return position_;
}
inline ::ADSB::GeoCoordinates* Aircraft::release_position() {
  clear_has_position();
  ::ADSB::GeoCoordinates* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Aircraft::set_allocated_position(::ADSB::GeoCoordinates* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Aircraft.position)
}

// optional double gpsCourse = 6;
inline bool Aircraft::has_gpscourse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Aircraft::set_has_gpscourse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Aircraft::clear_has_gpscourse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Aircraft::clear_gpscourse() {
  gpscourse_ = 0;
  clear_has_gpscourse();
}
inline double Aircraft::gpscourse() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.gpsCourse)
  return gpscourse_;
}
inline void Aircraft::set_gpscourse(double value) {
  set_has_gpscourse();
  gpscourse_ = value;
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.gpsCourse)
}

// optional double aerialSpeed = 7;
inline bool Aircraft::has_aerialspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Aircraft::set_has_aerialspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Aircraft::clear_has_aerialspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Aircraft::clear_aerialspeed() {
  aerialspeed_ = 0;
  clear_has_aerialspeed();
}
inline double Aircraft::aerialspeed() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.aerialSpeed)
  return aerialspeed_;
}
inline void Aircraft::set_aerialspeed(double value) {
  set_has_aerialspeed();
  aerialspeed_ = value;
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.aerialSpeed)
}

// optional double aerialAlt = 8;
inline bool Aircraft::has_aerialalt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Aircraft::set_has_aerialalt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Aircraft::clear_has_aerialalt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Aircraft::clear_aerialalt() {
  aerialalt_ = 0;
  clear_has_aerialalt();
}
inline double Aircraft::aerialalt() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.aerialAlt)
  return aerialalt_;
}
inline void Aircraft::set_aerialalt(double value) {
  set_has_aerialalt();
  aerialalt_ = value;
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.aerialAlt)
}

// optional double verticalSpeed = 9;
inline bool Aircraft::has_verticalspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Aircraft::set_has_verticalspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Aircraft::clear_has_verticalspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Aircraft::clear_verticalspeed() {
  verticalspeed_ = 0;
  clear_has_verticalspeed();
}
inline double Aircraft::verticalspeed() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.verticalSpeed)
  return verticalspeed_;
}
inline void Aircraft::set_verticalspeed(double value) {
  set_has_verticalspeed();
  verticalspeed_ = value;
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.verticalSpeed)
}

// optional string description = 10;
inline bool Aircraft::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Aircraft::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Aircraft::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Aircraft::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Aircraft::description() const {
  // @@protoc_insertion_point(field_get:ADSB.Aircraft.description)
  return *description_;
}
inline void Aircraft::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:ADSB.Aircraft.description)
}
inline void Aircraft::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:ADSB.Aircraft.description)
}
inline void Aircraft::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ADSB.Aircraft.description)
}
inline ::std::string* Aircraft::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ADSB.Aircraft.description)
  return description_;
}
inline ::std::string* Aircraft::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Aircraft::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Aircraft.description)
}

// -------------------------------------------------------------------

// Source

// required string sourceName = 1;
inline bool Source::has_sourcename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Source::set_has_sourcename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Source::clear_has_sourcename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Source::clear_sourcename() {
  if (sourcename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourcename_->clear();
  }
  clear_has_sourcename();
}
inline const ::std::string& Source::sourcename() const {
  // @@protoc_insertion_point(field_get:ADSB.Source.sourceName)
  return *sourcename_;
}
inline void Source::set_sourcename(const ::std::string& value) {
  set_has_sourcename();
  if (sourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
  // @@protoc_insertion_point(field_set:ADSB.Source.sourceName)
}
inline void Source::set_sourcename(const char* value) {
  set_has_sourcename();
  if (sourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
  // @@protoc_insertion_point(field_set_char:ADSB.Source.sourceName)
}
inline void Source::set_sourcename(const char* value, size_t size) {
  set_has_sourcename();
  if (sourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ADSB.Source.sourceName)
}
inline ::std::string* Source::mutable_sourcename() {
  set_has_sourcename();
  if (sourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourcename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ADSB.Source.sourceName)
  return sourcename_;
}
inline ::std::string* Source::release_sourcename() {
  clear_has_sourcename();
  if (sourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sourcename_;
    sourcename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Source::set_allocated_sourcename(::std::string* sourcename) {
  if (sourcename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sourcename_;
  }
  if (sourcename) {
    set_has_sourcename();
    sourcename_ = sourcename;
  } else {
    clear_has_sourcename();
    sourcename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Source.sourceName)
}

// optional string deviceName = 2;
inline bool Source::has_devicename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Source::set_has_devicename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Source::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Source::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& Source::devicename() const {
  // @@protoc_insertion_point(field_get:ADSB.Source.deviceName)
  return *devicename_;
}
inline void Source::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
  // @@protoc_insertion_point(field_set:ADSB.Source.deviceName)
}
inline void Source::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
  // @@protoc_insertion_point(field_set_char:ADSB.Source.deviceName)
}
inline void Source::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ADSB.Source.deviceName)
}
inline ::std::string* Source::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ADSB.Source.deviceName)
  return devicename_;
}
inline ::std::string* Source::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Source::set_allocated_devicename(::std::string* devicename) {
  if (devicename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete devicename_;
  }
  if (devicename) {
    set_has_devicename();
    devicename_ = devicename;
  } else {
    clear_has_devicename();
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Source.deviceName)
}

// -------------------------------------------------------------------

// ADSB_Message

// required .ADSB.ADSB_Message.SourceType sourceType = 1;
inline bool ADSB_Message::has_sourcetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADSB_Message::set_has_sourcetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADSB_Message::clear_has_sourcetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADSB_Message::clear_sourcetype() {
  sourcetype_ = 1;
  clear_has_sourcetype();
}
inline ::ADSB::ADSB_Message_SourceType ADSB_Message::sourcetype() const {
  // @@protoc_insertion_point(field_get:ADSB.ADSB_Message.sourceType)
  return static_cast< ::ADSB::ADSB_Message_SourceType >(sourcetype_);
}
inline void ADSB_Message::set_sourcetype(::ADSB::ADSB_Message_SourceType value) {
  assert(::ADSB::ADSB_Message_SourceType_IsValid(value));
  set_has_sourcetype();
  sourcetype_ = value;
  // @@protoc_insertion_point(field_set:ADSB.ADSB_Message.sourceType)
}

// -------------------------------------------------------------------

// Sample

// required .ADSB.Source source = 1;
inline bool Sample::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sample::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sample::clear_source() {
  if (source_ != NULL) source_->::ADSB::Source::Clear();
  clear_has_source();
}
inline const ::ADSB::Source& Sample::source() const {
  // @@protoc_insertion_point(field_get:ADSB.Sample.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::ADSB::Source* Sample::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::ADSB::Source;
  // @@protoc_insertion_point(field_mutable:ADSB.Sample.source)
  return source_;
}
inline ::ADSB::Source* Sample::release_source() {
  clear_has_source();
  ::ADSB::Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Sample::set_allocated_source(::ADSB::Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:ADSB.Sample.source)
}

// repeated .ADSB.Aircraft aircraft = 2;
inline int Sample::aircraft_size() const {
  return aircraft_.size();
}
inline void Sample::clear_aircraft() {
  aircraft_.Clear();
}
inline const ::ADSB::Aircraft& Sample::aircraft(int index) const {
  // @@protoc_insertion_point(field_get:ADSB.Sample.aircraft)
  return aircraft_.Get(index);
}
inline ::ADSB::Aircraft* Sample::mutable_aircraft(int index) {
  // @@protoc_insertion_point(field_mutable:ADSB.Sample.aircraft)
  return aircraft_.Mutable(index);
}
inline ::ADSB::Aircraft* Sample::add_aircraft() {
  // @@protoc_insertion_point(field_add:ADSB.Sample.aircraft)
  return aircraft_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ADSB::Aircraft >&
Sample::aircraft() const {
  // @@protoc_insertion_point(field_list:ADSB.Sample.aircraft)
  return aircraft_;
}
inline ::google::protobuf::RepeatedPtrField< ::ADSB::Aircraft >*
Sample::mutable_aircraft() {
  // @@protoc_insertion_point(field_mutable_list:ADSB.Sample.aircraft)
  return &aircraft_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ADSB

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ADSB::ADSB_Message_SourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ADSB::ADSB_Message_SourceType>() {
  return ::ADSB::ADSB_Message_SourceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sample_2eproto__INCLUDED
